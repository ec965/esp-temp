# Four Digit Seven Segment Library (ESP32)
![4dig7seg](https://external-content.duckduckgo.com/iu/?u=http%3A%2F%2Fwww.learningaboutelectronics.com%2Fimages%2F4-digit-7-segment-LED-display-pinout.png&f=1&nofb=1)

A library for interfacing with a seven segment display using an ESP32 and the [Arduino ESP32 HAL](https://github.com/espressif/arduino-esp32).

## Supported Characters
* __Numbers:__ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
* __Letters:__ a, c, f, h
* __Punctuation:__ - (dash), . (period)

## Usage
TLDR:
1. Set up a timer.
2. Create a display task to run the display. Suspend the display task based on the timer interrupt.
3. Create a queue to send strings to the display task.


The library can support both common annode and common cathode displays.
The option can be chosen with the `COMMON_ANNODE` and `COMMON_CATHODE` macros when creating the `FDigSSeg` object.

To display different numbers on each digit, the display switches at a high speed between digits to fool the human eye.
A timer is needed to set the switching (i.e. refresh rate) of the display.
The ESP32 has four hardware timers.
These timers can set up like so:
```C++
// size of the display queue
#define QSIZE 10
// there are 4 hardware timers numbered from 0 to 3
#define HARDWARETIMER 0 
// the number to divide the base clock frequency by.
// Most boards operate at 80MHz
#define TIMERDIVISION 80 
// Using a timer division of 80 gives 1micro-sec per tick of the timer
// Setting a frequency of 1600 gives us about a 60hz refresh rate on the display
#define TIMERFREQ 1700 
hw_timer_t* display_timer = NULL;

// timer interrupt callback to refresh the segment display 
void IRAM_ATTR onTimer(){
    xTaskResumeFromISR(display_handle); // handle that is assigned to the display task
}

void setup(){
    // init display refresh interrupt timer
    display_timer = timerBegin(HARDWARETIMER, TIMERDIVISION, true);
    timerAttachInterrupt(display_timer, &onTimer, true); // assign the ISR function here
    timerAlarmWrite(display_timer, TIMERFREQ, true);
    timerAlarmEnable(display_timer);
}
```

You must use a task hanlder to connect the timer interrupt to the display task.
```C++
#include "FdigSseg.h"
// pins for the 4 digit 7 segment display
const uint8_t digit_pins[] = {26,27,14,12}; // digits
const uint8_t seg_pins[] = {21, 19, 18, 5, 17, 16, 4, 15}; // segments
// four digit seven segment display object
FdigSseg segdisp (digit_pins, seg_pins, COMMON_ANODE);
// task handler to refresh the display based on the timer
TaskHandle_t display_handle;

// - snip - //

void setup(){
    Serial.begin(115200);
    segdisp.init();

    // - snip - //
    
    xTaskCreate(display_task, 
        "display task", 
        4000, 
        NULL, 
        tskIDLE_PRIORITY, // tskIDLE_PRIORITY must be enabled when using a task handle
        &display_handle // bind the display task handle to the display task
    ); 
}
```

A display task will handle showing numbers on the display.
The display task will unsuspend based on an interrupt generated by the timer.
```C++
// The max size of a string that can be sent to segment display is 9
// example: '0.0.0.0.'
#define STRINGSIZE 9 

// - snip - //

void display_task(void * paramter){
    char str[STRINGSIZE];
    while(1){
        vTaskSuspend(display_handle); // suspend the task while waiting for the next timer cycle
        if (xQueueReceive(display_queue, &str, 0) == pdTRUE){ // don't block
            Serial.print("Displaying:");
            Serial.println(str);
        }
        segdisp.display_string(str); // display the string
    }
    vTaskDelete(NULL);
}
```

Finally, you can use a queue to send strings into the display task.
```C++
// size of the display queue
#define QSIZE 10

// - snip - //

// Queue to send strings to the display task
QueueHandle_t display_queue;

void setup(){
    
    // - snip - //

    // initialize the queue
    display_queue = xQueueCreate(QSIZE, STRINGSIZE*sizeof(char));
    
    // - snip - //

}

void loop(){
    char str[STRINGSIZE] = "1234";
    xQueueSend(display_queue, &str, portMAX_DELAY);
    delay(1000); // this will not block, it is equivalent to vTaskDelay(1000 / portTICK_PERIOD_MS)
    
    sprintf(str, "2341");
    xQueueSend(display_queue, &str, portMAX_DELAY);
    delay(1000); 

    sprintf(str, "3412");
    xQueueSend(display_queue, &str, portMAX_DELAY);
    delay(1000); 

    sprintf(str, "4123");
    xQueueSend(display_queue, &str, portMAX_DELAY);
    delay(1000);
}
```

A full example can be found in the examples folder.

## Single Digit 7 Segment Display
While the library is made for a four digit seven segment display, a one digit seven segment display can also be used by only have one pin number in the digits array.
```C++
const uint8_t digit_pin[] = {26}; // single digit display
const uint8_t seg_pins[] = {21, 19, 18, 5, 17, 16, 4, 15}; // segments
FdigSseg segdisp (digit_pin, seg_pins, COMMON_ANODE);
```
